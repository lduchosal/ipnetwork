{
  "api/System.Net.BigIntegerExtensions.html": {
    "href": "api/System.Net.BigIntegerExtensions.html",
    "title": "Class BigIntegerExtensions | IPNetwork",
    "summary": "Class BigIntegerExtensions Namespace System.Net Assembly System.Net.IPNetwork.dll Extension methods to convert BigInteger instances to hexadecimal, octal, and binary strings. [CLSCompliant(true)] public static class BigIntegerExtensions Inheritance object BigIntegerExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods PositiveReverse(BigInteger, int) Reverse a Positive BigInteger ONLY Bitwise ~ operator Input : FF FF FF FF Width : 4 Result : 00 00 00 00 Input : 00 00 00 00 Width : 4 Result : FF FF FF FF Input : FF FF FF FF Width : 8 Result : FF FF FF FF 00 00 00 00 Input : 00 00 00 00 Width : 8 Result : FF FF FF FF FF FF FF FF. public static BigInteger PositiveReverse(this BigInteger input, int width) Parameters input BigInteger The positive number to bitwise reverse. width int The width of the parameter. Returns BigInteger A number representing the input bitwise reversed. ToBinaryString(BigInteger) Converts a BigInteger to a binary string. public static string ToBinaryString(this BigInteger bigint) Parameters bigint BigInteger A BigInteger. Returns string A string containing a binary representation of the supplied BigInteger. ToHexadecimalString(BigInteger) Converts a BigInteger to a hexadecimal string. public static string ToHexadecimalString(this BigInteger bigint) Parameters bigint BigInteger A BigInteger. Returns string A string containing a hexadecimal representation of the supplied BigInteger. ToOctalString(BigInteger) Converts a BigInteger to an octal string. public static string ToOctalString(this BigInteger bigint) Parameters bigint BigInteger A BigInteger. Returns string A string containing an octal representation of the supplied BigInteger."
  },
  "api/System.Net.CidrClassFull.html": {
    "href": "api/System.Net.CidrClassFull.html",
    "title": "Class CidrClassFull | IPNetwork",
    "summary": "Class CidrClassFull Namespace System.Net Assembly System.Net.IPNetwork.dll Class CidrClassFull tries to guess CIDR in a ClassFull way. public sealed class CidrClassFull : ICidrGuess Inheritance object CidrClassFull Implements ICidrGuess Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods TryGuessCidr(string, out byte) IPV4 : Class Leading bits Default netmask A (CIDR /8) 00 255.0.0.0 A (CIDR /8) 01 255.0.0.0 B (CIDR /16) 10 255.255.0.0 C (CIDR /24) 11 255.255.255.0 IPV6 : 64. public bool TryGuessCidr(string ip, out byte cidr) Parameters ip string A string representing the CIDR to convert. cidr byte A byte representing the netmask in cidr format (/24). Returns bool true if ip was converted successfully; otherwise, false."
  },
  "api/System.Net.CidrClassLess.html": {
    "href": "api/System.Net.CidrClassLess.html",
    "title": "Class CidrClassLess | IPNetwork",
    "summary": "Class CidrClassLess Namespace System.Net Assembly System.Net.IPNetwork.dll Try to guess a CIDR in a ClassLess way: ipv4 = 32, ipv6 = 128. public sealed class CidrClassLess : ICidrGuess Inheritance object CidrClassLess Implements ICidrGuess Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods TryGuessCidr(string, out byte) IPV4 : 32 IPV6 : 128. public bool TryGuessCidr(string ip, out byte cidr) Parameters ip string A string representing an IPAddress that will be used to guess CIDR. cidr byte A byte representing the netmask in cidr format (/24). Returns bool true if ip was converted successfully; otherwise, false."
  },
  "api/System.Net.CidrGuess.html": {
    "href": "api/System.Net.CidrGuess.html",
    "title": "Class CidrGuess | IPNetwork",
    "summary": "Class CidrGuess Namespace System.Net Assembly System.Net.IPNetwork.dll A static helper CidrGuess class. public static class CidrGuess Inheritance object CidrGuess Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ClassFull Gets classFull guesser. public static ICidrGuess ClassFull { get; } Property Value ICidrGuess ClassLess Gets classLess guesser. public static ICidrGuess ClassLess { get; } Property Value ICidrGuess NetworkAware Gets a NetworkAware guesser. public static ICidrGuess NetworkAware { get; } Property Value ICidrGuess"
  },
  "api/System.Net.CidrNetworkAware.html": {
    "href": "api/System.Net.CidrNetworkAware.html",
    "title": "Class CidrNetworkAware | IPNetwork",
    "summary": "Class CidrNetworkAware Namespace System.Net Assembly System.Net.IPNetwork.dll If your CidrGuess is “network-aware” based only on what humans usually encode in the textual address, a good heuristic is: IPv4 (dotted-quad) • Treat trailing 0s as “network bits” and trailing 255s as a “wildcard” hint for the same boundary. • Otherwise, fall back to /32 (no safe aggregation from the string alone). • Special case: 0.0.0.0 (or 255.255.255.255) → /0. Rule of thumb Ends with .0 → /24 Ends with .0.0 or .255.255 → /16 Ends with .0.0.0 or .255.255.255 → /8 Else → /32 Matches your examples Parse(\"192.0.43.8\") → /32 Parse(\"192.0.43.0\") → /24 Parse(\"192.43.0.0\") → /16 Parse(\"192.0.43.255\") → /24 (wildcard hint) Parse(\"192.43.255.255\") → /16 (wildcard hint) So: in a network-aware context like this, you generally don’t emit /25, /26, etc., because there’s no reliable visual cue for those in dotted-quad—stick to /32, /24, /16, /8, /0. IPv6 (colon-hex) IPv6 is grouped by hextets (16-bit chunks), so mirror the idea at 16-bit boundaries. Use trailing :0000 hextets as “network bits”. Otherwise, fall back to /128. Note: operationally, /64 is the standard host subnet size, but you should still infer from the string, not assumptions. Rule of thumb Ends with :0000 → /112 Ends with :0000:0000 → /96 Ends with three trailing :0000 → /80 … Ends with four trailing :0000 → /64 Else → /128 Examples 2001:db8:1:2:3:4:5:6 → /128 2001:db8:1:2:3:4:5:0000 → /112 2001:db8:1:2:3:4:0000:0000 → /96 2001:db8:1:2:3:0000:0000:0000 → /80 2001:db8:1:2:0000:0000:0000:0000 → /64 TL;DR IPv4: stick to /32, /24, /16, /8, /0 based on trailing .0/.255; otherwise /32. IPv6: infer /128, /112, /96, /80, /64, … based on trailing :0000 groups; otherwise /128. public sealed class CidrNetworkAware : ICidrGuess Inheritance object CidrNetworkAware Implements ICidrGuess Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods TryGuessCidr(string, out byte) Tries to guess a network-aware CIDR prefix length from a textual IP address. IPv4: honors trailing 0s (network) and trailing 255s (wildcard hint) at octet boundaries. IPv6: honors trailing :0000 at hextet (16-bit) boundaries. Optional trailing :ffff wildcard heuristic is off by default. public bool TryGuessCidr(string ip, out byte cidr) Parameters ip string IP address as string (no slash). Example: \"192.0.43.0\" or \"2001:db8::\". cidr byte Guessed CIDR (0..32 for IPv4, 0..128 for IPv6). Returns bool true if parsed and guessed; false if input is not a valid IP address."
  },
  "api/System.Net.Filter.html": {
    "href": "api/System.Net.Filter.html",
    "title": "Enum Filter | IPNetwork",
    "summary": "Enum Filter Namespace System.Net Assembly System.Net.IPNetwork.dll Represents different filters for a collection of items. public enum Filter Fields All = 0 Every IPAdresses are returned Usable = 1 Returns only usable IPAdresses"
  },
  "api/System.Net.FilterEnum.html": {
    "href": "api/System.Net.FilterEnum.html",
    "title": "Enum FilterEnum | IPNetwork",
    "summary": "Enum FilterEnum Namespace System.Net Assembly System.Net.IPNetwork.dll Represents different filters for a collection of items. [Obsolete(\"Use Filter instead\")] public enum FilterEnum Fields All = 0 Every IPAdresses are returned Usable = 1 Returns only usable IPAdresses"
  },
  "api/System.Net.ICidrGuess.html": {
    "href": "api/System.Net.ICidrGuess.html",
    "title": "Interface ICidrGuess | IPNetwork",
    "summary": "Interface ICidrGuess Namespace System.Net Assembly System.Net.IPNetwork.dll An interface to have multiple implemntatino ao CIDR Guesser. public interface ICidrGuess Methods TryGuessCidr(string, out byte) Try to guess the CIDR. bool TryGuessCidr(string ip, out byte cidr) Parameters ip string An IPAddress to guess the ip network CIDR. cidr byte A byte representing the netmask in cidr format (/24). Returns bool true if ip was converted successfully; otherwise, false."
  },
  "api/System.Net.IPAddressCollection.html": {
    "href": "api/System.Net.IPAddressCollection.html",
    "title": "Class IPAddressCollection | IPNetwork",
    "summary": "Class IPAddressCollection Namespace System.Net Assembly System.Net.IPNetwork.dll Represents a collection of IP addresses within a specific IP network. public class IPAddressCollection : IEnumerable<IPAddress>, IEnumerable, IEnumerator<IPAddress>, IEnumerator, IDisposable Inheritance object IPAddressCollection Implements IEnumerable<IPAddress> IEnumerable IEnumerator<IPAddress> IEnumerator IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count Gets the count of IP addresses within the network. public BigInteger Count { get; } Property Value BigInteger The count of IP addresses within the network. Current Gets the current IPAddress from the collection. public IPAddress Current { get; } Property Value IPAddress The current IPAddress. this[BigInteger] Gets the IP address corresponding to the given index from the IPNetwork collection. public IPAddress this[BigInteger i] { get; } Parameters i BigInteger The index of the IP address to retrieve. Property Value IPAddress The IP address corresponding to the given index. Exceptions ArgumentOutOfRangeException Thrown when the given index is greater than or equal to the Count property of the IPNetwork collection. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) Dispose instance protected virtual void Dispose(bool disposing) Parameters disposing bool MoveNext() Advances the enumerator to the next element of the collection. public bool MoveNext() Returns bool true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection. Exceptions InvalidOperationException The collection was modified after the enumerator was created. Reset() Sets the enumerator to its initial position, which is before the first element in the collection. public void Reset() Exceptions InvalidOperationException The collection was modified after the enumerator was created. NotSupportedException The enumerator does not support being reset."
  },
  "api/System.Net.IPAddressExtensions.html": {
    "href": "api/System.Net.IPAddressExtensions.html",
    "title": "Class IPAddressExtensions | IPNetwork",
    "summary": "Class IPAddressExtensions Namespace System.Net Assembly System.Net.IPNetwork.dll A collection of extension functions applied to an IPAddress value. public static class IPAddressExtensions Inheritance object IPAddressExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AsIPNetwork(IPAddress) Convert an IPAddress value into a single-address IPNetwork for that address. public static IPNetwork2 AsIPNetwork(this IPAddress addr) Parameters addr IPAddress IPAddress to convert. Returns IPNetwork2 IPNetwork object covering that IPAddress only."
  },
  "api/System.Net.IPNetwork2.html": {
    "href": "api/System.Net.IPNetwork2.html",
    "title": "Class IPNetwork2 | IPNetwork",
    "summary": "Class IPNetwork2 Namespace System.Net Assembly System.Net.IPNetwork.dll IP Network utility class. Use IPNetwork.Parse to create instances. [Serializable] [CLSCompliant(true)] public sealed class IPNetwork2 : ISerializable, IComparable<IPNetwork2>, IEquatable<IPNetwork2> Inheritance object IPNetwork2 Implements ISerializable IComparable<IPNetwork2> IEquatable<IPNetwork2> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Extension Methods IPNetwork2UlaExtension.IsLocallyAssignedUla(IPNetwork2) IPNetwork2UlaExtension.IsUla(IPNetwork2) Constructors IPNetwork2() Initializes a new instance of the IPNetwork2 class. Created for DataContractSerialization. Better use static methods IPNetwork.Parse() to create IPNetworks. public IPNetwork2() IPNetwork2(IPAddress, byte) Initializes a new instance of the IPNetwork2 class. Creates a new IPNetwork. public IPNetwork2(IPAddress ipaddress, byte cidr) Parameters ipaddress IPAddress An ipaddress. cidr byte A byte representing the netmask in cidr format (/24). Exceptions ArgumentNullException ipaddress is null. Properties AddressFamily Gets address Family. public AddressFamily AddressFamily { get; } Property Value AddressFamily Broadcast Gets broadcast address. public IPAddress Broadcast { get; } Property Value IPAddress Cidr Gets the CIDR netmask notation. public byte Cidr { get; } Property Value byte First Gets first IPAddress in Network. public IPAddress First { get; } Property Value IPAddress FirstUsable Gets first usable IPAddress in Network. public IPAddress FirstUsable { get; } Property Value IPAddress IANA_ABLK_RESERVED1 Gets 10.0.0.0/8. public static IPNetwork2 IANA_ABLK_RESERVED1 { get; } Property Value IPNetwork2 The IANA reserved IPNetwork 10.0.0.0/8. IANA_BBLK_RESERVED1 Gets 172.12.0.0/12. public static IPNetwork2 IANA_BBLK_RESERVED1 { get; } Property Value IPNetwork2 The IANA reserved IPNetwork 172.12.0.0/12. IANA_CBLK_RESERVED1 Gets 192.168.0.0/16. public static IPNetwork2 IANA_CBLK_RESERVED1 { get; } Property Value IPNetwork2 The IANA reserved IPNetwork 192.168.0.0/16. Last Gets last IPAddress in Network. public IPAddress Last { get; } Property Value IPAddress LastUsable Gets last usable IPAddress in Network. public IPAddress LastUsable { get; } Property Value IPAddress Netmask Gets netmask. public IPAddress Netmask { get; } Property Value IPAddress Network Gets network address. public IPAddress Network { get; } Property Value IPAddress Total Gets number of IPAddress in Network. public BigInteger Total { get; } Property Value BigInteger Usable Gets number of usable IPAddress in Network. According to : https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#IPv4_CIDR_blocks Address Mask Total Usable Network Broadcast FirstUsable LastUsable Typical use 1.0.0.1/32 255.255.255.255 1 1 1.0.0.1 1.0.0.1 1.0.0.1 1.0.0.1 Host route 1.0.0.1/31 255.255.255.254 2 2 1.0.0.1 1.0.0.2 1.0.0.1 1.0.0.2 Point-to-point links (RFC 3021) ... public BigInteger Usable { get; } Property Value BigInteger Value Gets or sets a value indicating whether gets or sets the value of the IPNetwork property. [DataMember(Name = \"IPNetwork\", IsRequired = true)] public string Value { get; set; } Property Value string WildcardMask Gets netmask Inverse https://en.wikipedia.org/wiki/Wildcard_mask A wildcard mask is a mask of bits that indicates which parts of an IP address are available for examination. In the Cisco IOS,[1] they are used in several places, for example: To indicate the size of a network or subnet for some routing protocols, such as OSPF. To indicate what IP addresses should be permitted or denied in access control lists(ACLs). A wildcard mask can be thought of as an inverted subnet mask.For example, a subnet mask of 255.255.255.0 (binary equivalent = 11111111.11111111.11111111.00000000) inverts to a wildcard mask of 0.0.0.255 (binary equivalent = 00000000.00000000.00000000.11111111). A wild card mask is a matching rule.[2] The rule for a wildcard mask is: 0 means that the equivalent bit must match 1 means that the equivalent bit does not matter Any wildcard bit-pattern can be masked for examination.For example, a wildcard mask of 0.0.0.254 (binary equivalent = 00000000.00000000.00000000.11111110) applied to IP address 10.10.10.2 (00001010.00001010.00001010.00000010) will match even-numbered IP addresses 10.10.10.0, 10.10.10.2, 10.10.10.4, 10.10.10.6 etc. Same mask applied to 10.10.10.1 (00001010.00001010.00001010.00000001) will match odd-numbered IP addresses 10.10.10.1, 10.10.10.3, 10.10.10.5 etc. A network and wildcard mask combination of 1.1.1.1 0.0.0.0 would match an interface configured exactly with 1.1.1.1 only, and nothing else. Wildcard masks are used in situations where subnet masks may not apply.For example, when two affected hosts fall in different subnets, the use of a wildcard mask will group them together. List of wildcard masks Slash Netmask Wildcard mask /32 255.255.255.255 0.0.0.0 /31 255.255.255.254 0.0.0.1 /30 255.255.255.252 0.0.0.3 /29 255.255.255.248 0.0.0.7 /28 255.255.255.240 0.0.0.15 /27 255.255.255.224 0.0.0.31 /26 255.255.255.192 0.0.0.63 /25 255.255.255.128 0.0.0.127 /24 255.255.255.0 0.0.0.255 /23 255.255.254.0 0.0.1.255 /22 255.255.252.0 0.0.3.255 /21 255.255.248.0 0.0.7.255 /20 255.255.240.0 0.0.15.255 /19 255.255.224.0 0.0.31.255 /18 255.255.192.0 0.0.63.255 /17 255.255.128.0 0.0.127.255 /16 255.255.0.0 0.0.255.255 /15 255.254.0.0 0.1.255.255 /14 255.252.0.0 0.3.255.255 /13 255.248.0.0 0.7.255.255 /12 255.240.0.0 0.15.255.255 /11 255.224.0.0 0.31.255.255 /10 255.192.0.0 0.63.255.255 /9 255.128.0.0 0.127.255.255 /8 255.0.0.0 0.255.255.255 /7 254.0.0.0 1.255.255.255 /6 252.0.0.0 3.255.255.255 /5 248.0.0.0 7.255.255.255 /4 240.0.0.0 15.255.255.255 /3 224.0.0.0 31.255.255.255 /2 192.0.0.0 63.255.255.255 /1 128.0.0.0 127.255.255.255 /0 0.0.0.0 255.255.255.255. public IPAddress WildcardMask { get; } Property Value IPAddress Methods BitsSet(IPAddress) Count bits set to 1 in netmask. [CLSCompliant(false)] public static uint BitsSet(IPAddress netmask) Parameters netmask IPAddress A number representing the netmask to count bits from. Returns uint The number of bytes set to 1. Compare(IPNetwork2, IPNetwork2) Compares two IPNetwork2 instances. public static int Compare(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 The first IPNetwork2 instance to compare. right IPNetwork2 The second IPNetwork2 instance to compare. Returns int A value indicating the relative order of the two IPNetwork2 instances. Zero if the instances are equal. A negative value if left is less than right. A positive value if left is greater than right. CompareTo(IPNetwork2) Compare two ipnetworks. public int CompareTo(IPNetwork2 other) Parameters other IPNetwork2 The other network to compare to. Returns int A signed number indicating the relative values of this instance and value. CompareTo(object) Compare two ipnetworks. public int CompareTo(object obj) Parameters obj object The other object to compare to. Returns int A signed number indicating the relative values of this instance and value. Contains(IPAddress) return true if ipaddress is contained in network. [CLSCompliant(false)] public bool Contains(IPAddress contains) Parameters contains IPAddress A string containing an ip address to convert. Returns bool true if ipaddress is contained into the IP Network; otherwise, false. Contains(IPNetwork2) return true is network2 is fully contained in network. public bool Contains(IPNetwork2 contains) Parameters contains IPNetwork2 The network to test. Returns bool It returns the boolean value. If network2 is in IPNetwork then it returns True, otherwise returns False. Contains(IPNetwork2, IPAddress) Determines whether the given IP address is part of the given IP network. [Obsolete(\"static Contains is deprecated, please use instance Contains.\")] public static bool Contains(IPNetwork2 network, IPAddress ipaddress) Parameters network IPNetwork2 The IP network. ipaddress IPAddress The IP address. Returns bool true if the IP address is part of the IP network; otherwise, false. Contains(IPNetwork2, IPNetwork2) Determines if the given network contains the specified network2. [Obsolete(\"static Contains is deprecated, please use instance Contains.\")] public static bool Contains(IPNetwork2 network, IPNetwork2 network2) Parameters network IPNetwork2 The network to check for containment. network2 IPNetwork2 The network to check if it is contained. Returns bool true if the network contains the network2; otherwise, false. Equals(IPNetwork2) Compare two ipnetworks. public bool Equals(IPNetwork2 other) Parameters other IPNetwork2 An IPNetwork to compare to this instance. Returns bool true if obj has the same value as this instance; otherwise, false. Equals(IPNetwork2, IPNetwork2) Compare two ipnetworks. public static bool Equals(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 An IPNetwork to compare. right IPNetwork2 An other IPNetwork to compare to. Returns bool true if obj has the same value as this instance; otherwise, false. Equals(object) Compare two ipnetworks. public override bool Equals(object obj) Parameters obj object An object value to compare to this instance. Returns bool true if obj has the same value as this instance; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. IsIANAReserved() return true if ipnetwork is contained in IANA_ABLK_RESERVED1, IANA_BBLK_RESERVED1, IANA_CBLK_RESERVED1. public bool IsIANAReserved() Returns bool true if the ipnetwork is a IANA reserverd IP Netowkr ; otherwise, false. IsIANAReserved(IPAddress) return true if ipaddress is contained in IANA_ABLK_RESERVED1, IANA_BBLK_RESERVED1, IANA_CBLK_RESERVED1. public static bool IsIANAReserved(IPAddress ipaddress) Parameters ipaddress IPAddress A string containing an ip address to convert. Returns bool true if ipaddress is a IANA reserverd IP Netowkr ; otherwise, false. IsIANAReserved(IPNetwork2) Determines whether the specified IP network is reserved according to the IANA Reserved ranges. [Obsolete(\"static IsIANAReserved is deprecated, please use instance IsIANAReserved.\")] public static bool IsIANAReserved(IPNetwork2 ipnetwork) Parameters ipnetwork IPNetwork2 The IP network to check. Returns bool true if the specified IP network is reserved according to the IANA Reserved ranges; otherwise, false. Remarks This method is obsolete and should not be used. Please use the instance method, see IsIANAReserved\" instead. Throws an ArgumentNullException if ipnetwork is null. ListIPAddress(Filter) List all ip addresses in a subnet. public IPAddressCollection ListIPAddress(Filter filter = Filter.All) Parameters filter Filter Filter IPAdresses from IPNetwork. Returns IPAddressCollection The filterted IPAdresses contained in ipnetwork. ListIPAddress(FilterEnum) List all ip addresses in a subnet. [Obsolete(\"Use overload that uses Filter instead\")] public IPAddressCollection ListIPAddress(FilterEnum filter) Parameters filter FilterEnum Filter IPAdresses from IPNetwork. Returns IPAddressCollection The filterted IPAdresses contained in ipnetwork. ListIPAddress(IPNetwork2) List all ip addresses in a subnet. [Obsolete(\"static ListIPAddress is deprecated, please use instance ListIPAddress.\")] public static IPAddressCollection ListIPAddress(IPNetwork2 ipnetwork) Parameters ipnetwork IPNetwork2 The network to list IPAdresses. Returns IPAddressCollection All the IPAdresses contained in ipnetwork. Overlap(IPNetwork2) return true is network2 overlap network. public bool Overlap(IPNetwork2 network2) Parameters network2 IPNetwork2 The network to test. Returns bool true if network2 overlaps into the IP Network; otherwise, false. Overlap(IPNetwork2, IPNetwork2) Determines if two IPNetwork2 objects overlap each other. [Obsolete(\"static Overlap is deprecated, please use instance Overlap.\")] public static bool Overlap(IPNetwork2 network, IPNetwork2 network2) Parameters network IPNetwork2 The first IPNetwork2 object. network2 IPNetwork2 The second IPNetwork2 object. Returns bool Returns true if the two IPNetwork2 objects overlap, otherwise false. Parse(IPAddress, IPAddress) 192.168.168.100 255.255.255.0 Network : 192.168.168.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.168.1 End : 192.168.168.254 Broadcast : 192.168.168.255. public static IPNetwork2 Parse(IPAddress ipaddress, IPAddress netmask) Parameters ipaddress IPAddress A string containing an ip address to convert. netmask IPAddress A netmask to be used to create the IPNetwork. Returns IPNetwork2 An IPNetwork equivalent to the network contained in ipaddress/netmask. Parse(string) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static IPNetwork2 Parse(string network) Parameters network string A string containing an ip network to convert. Returns IPNetwork2 An IPNetwork equivalent to the network contained in string network. Parse(string, bool) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static IPNetwork2 Parse(string network, bool sanitanize) Parameters network string A string containing an ip network to convert. sanitanize bool If true, removes invalid characters and normalizes whitespace from the network string, keeping only valid network address characters (0-9, a-f, A-F, ., /, :, and spaces). Returns IPNetwork2 An IPNetwork equivalent to the network contained in string network. Parse(string, byte) 192.168.168.100/24 Network : 192.168.168.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.168.1 End : 192.168.168.254 Broadcast : 192.168.168.255. public static IPNetwork2 Parse(string ipaddress, byte cidr) Parameters ipaddress string A string containing an ip address to convert. cidr byte A byte representing the netmask in cidr format (/24). Returns IPNetwork2 An IPNetwork equivalent to the network contained in ipaddress/cidr. Parse(string, ICidrGuess) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static IPNetwork2 Parse(string network, ICidrGuess cidrGuess) Parameters network string A string containing an ip network to convert. cidrGuess ICidrGuess A ICidrGuess implementation that will be used to guess CIDR during conversion. Returns IPNetwork2 An IPNetwork equivalent to the network contained in string network. Parse(string, ICidrGuess, bool) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static IPNetwork2 Parse(string network, ICidrGuess cidrGuess, bool sanitanize) Parameters network string A string containing an ip network to convert. cidrGuess ICidrGuess A ICidrGuess implementation that will be used to guess CIDR during conversion. sanitanize bool If true, removes invalid characters and normalizes whitespace from the network string, keeping only valid network address characters (0-9, a-f, A-F, ., /, :, and spaces). Returns IPNetwork2 An IPNetwork equivalent to the network contained in string network. Parse(string, string) 192.168.168.100 - 255.255.255.0 Network : 192.168.168.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.168.1 End : 192.168.168.254 Broadcast : 192.168.168.255 ```. public static IPNetwork2 Parse(string ipaddress, string netmask) Parameters ipaddress string A string containing an ip address to convert. netmask string A string representing a netmask in std format (255.255.255.0). Returns IPNetwork2 An IPNetwork equivalent to the network contained in ipaddress/netmask. ParseRange(string) 192.168.1.45 - 192.168.1.65 192.168.1.45/32 (covers: 192.168.1.45) 192.168.1.46/31 (covers: 192.168.1.46 - 192.168.1.47) 192.168.1.48/28 (covers: 192.168.1.48 - 192.168.1.63) 192.168.1.64/31 (covers: 192.168.1.64 - 192.168.1.65) public static IEnumerable<IPNetwork2> ParseRange(string range) Parameters range string A string containing an ip range to convert (192.168.1.45 - 192.168.1.65). Returns IEnumerable<IPNetwork2> An IPNetwork List equivalent to the network contained in the range. ParseRange(string, string) 192.168.1.45, 192.168.1.65 192.168.1.45/32 (covers: 192.168.1.45) 192.168.1.46/31 (covers: 192.168.1.46 - 192.168.1.47) 192.168.1.48/28 (covers: 192.168.1.48 - 192.168.1.63) 192.168.1.64/31 (covers: 192.168.1.64 - 192.168.1.65) public static IEnumerable<IPNetwork2> ParseRange(string start, string end) Parameters start string A string containing a start range ip address. end string A string containing a end range ip address. Returns IEnumerable<IPNetwork2> An IPNetwork List equivalent to the network contained in the range. Print() Print an ipnetwork in a clear representation string. public string Print() Returns string Dump an IPNetwork representation as string. Print(IPNetwork2) Print an ipnetwork in a clear representation string. [Obsolete(\"static Print is deprecated, please use instance Print.\")] public static string Print(IPNetwork2 ipnetwork) Parameters ipnetwork IPNetwork2 The ipnetwork. Returns string Dump an IPNetwork representation as string. Exceptions ArgumentNullException When arg is null. Subnet(byte) Subnet a network into multiple nets of cidr mask Subnet 192.168.0.0/24 into cidr 25 gives 192.168.0.0/25, 192.168.0.128/25 Subnet 10.0.0.0/8 into cidr 9 gives 10.0.0.0/9, 10.128.0.0/9. public IPNetworkCollection Subnet(byte cidr1) Parameters cidr1 byte A byte representing the CIDR to be used to subnet the current IPNetwork. Returns IPNetworkCollection A IPNetworkCollection split by CIDR. Subnet(IPNetwork2, byte) Subnet method is used to divide the given IP network into subnets with the specified CIDR. [Obsolete(\"static Subnet is deprecated, please use instance Subnet.\")] public static IPNetworkCollection Subnet(IPNetwork2 network, byte cidr) Parameters network IPNetwork2 The IP network to be subnetted. cidr byte The CIDR (Classless Inter-Domain Routing) value used to subnet the network. Returns IPNetworkCollection A collection of subnets created from the given network using the specified CIDR. Subtract(IPNetwork2) Implementation for IP network symmetric difference (subtraction) 0.0.0.0/0 - 10.0.0.1/32 = [ 0.0.0.0/5, 8.0.0.0/7, 10.0.0.0/32, 10.0.0.2/31, 10.0.0.4/30, 10.0.0.8/29, 10.0.0.16/28, 10.0.0.32/27, 10.0.0.64/26, 10.0.0.128/25, 10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, 10.0.8.0/21, 10.0.16.0/20, 10.0.32.0/19, 10.0.64.0/18, 10.0.128.0/17, 10.1.0.0/16, 10.2.0.0/15, 10.4.0.0/14, 10.8.0.0/13, 10.16.0.0/12, 10.32.0.0/11, 10.64.0.0/10, 10.128.0.0/9, 11.0.0.0/8, 12.0.0.0/6, 16.0.0.0/4, 32.0.0.0/3, 64.0.0.0/2, 128.0.0.0/1 ]. public List<IPNetwork2> Subtract(IPNetwork2 network2) Parameters network2 IPNetwork2 The network to subtract. Returns List<IPNetwork2> A list of IP Network. Supernet(IPNetwork2) Supernet two consecutive cidr equal subnet into a single one 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 10.1.0.0/16 + 10.0.0.0/16 = 10.0.0.0/15 192.168.0.0/24 + 192.168.0.0/25 = 192.168.0.0/24. public IPNetwork2 Supernet(IPNetwork2 network2) Parameters network2 IPNetwork2 The network to supernet with. Returns IPNetwork2 A super netted IP Network. Supernet(IPNetwork2, IPNetwork2) Supernet two consecutive cidr equal subnet into a single one 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 10.1.0.0/16 + 10.0.0.0/16 = 10.0.0.0/15 192.168.0.0/24 + 192.168.0.0/25 = 192.168.0.0/24. [Obsolete(\"static Supernet is deprecated, please use instance Supernet.\")] public static IPNetwork2 Supernet(IPNetwork2 network, IPNetwork2 network2) Parameters network IPNetwork2 the network. network2 IPNetwork2 The network to supernet with. Returns IPNetwork2 A super netted IP Network. Supernet(IPNetwork2[]) Supernet a list of subnet 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 192.168.0.0/24 + 192.168.1.0/24 + 192.168.2.0/24 + 192.168.3.0/24 = 192.168.0.0/22. public static IPNetwork2[] Supernet(IPNetwork2[] ipnetworks) Parameters ipnetworks IPNetwork2[] A list of IPNetwork to merge into common supernets. Returns IPNetwork2[] The result of IPNetwork if merges succeed, the first ipnetwork otherwise. ToBigInteger(IPAddress) Convert an IPAddress to decimal 0.0.0.0 -> 0 0.0.1.0 -> 256. public static BigInteger ToBigInteger(IPAddress ipaddress) Parameters ipaddress IPAddress A string containing an ip address to convert. Returns BigInteger A number representing the ipaddress. ToCidr(IPAddress) Convert netmask to CIDR 255.255.255.0 -> 24 255.255.0.0 -> 16 255.0.0.0 -> 8. public static byte ToCidr(IPAddress netmask) Parameters netmask IPAddress An IP Address representing the CIDR to convert. Returns byte A byte representing the CIDR converted from the netmask. ToIPAddress(BigInteger, AddressFamily) Transform a uint ipaddress into IPAddress object. public static IPAddress ToIPAddress(BigInteger ipaddress, AddressFamily family) Parameters ipaddress BigInteger A number representing an ip address to convert. family AddressFamily Either IPv4 or IPv6. Returns IPAddress An IPAddress. ToNetmask(byte, AddressFamily) Convert CIDR to netmask 24 -> 255.255.255.0 16 -> 255.255.0.0 8 -> 255.0.0.0. public static IPAddress ToNetmask(byte cidr, AddressFamily family) Parameters cidr byte A byte representing the netmask in cidr format (/24). family AddressFamily Either IPv4 or IPv6. Returns IPAddress An IPAddress representing cidr. ToString() Returns a string representation of the object. public override string ToString() Returns string A string representation of the object which includes the Network and Cidr values separated by a \"/\". ToUint(byte, AddressFamily) Convert a cidr to BigInteger netmask. public static BigInteger ToUint(byte cidr, AddressFamily family) Parameters cidr byte A byte representing the netmask in cidr format (/24). family AddressFamily Either IPv4 or IPv6. Returns BigInteger A number representing the netmask in CIDR form. TryGuessCidr(string, out byte) Delegate to CidrGuess ClassFull guessing of cidr. public static bool TryGuessCidr(string ip, out byte cidr) Parameters ip string A string representing an IPAdress that will be used to guess the corresponding CIDR. cidr byte The resulting CIDR as byte. Returns bool true if cidr was guessed successfully; otherwise, false. TryParse(IPAddress, IPAddress, out IPNetwork2) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static bool TryParse(IPAddress ipaddress, IPAddress netmask, out IPNetwork2 ipnetwork) Parameters ipaddress IPAddress An IPAddress to convert. netmask IPAddress An IPAddress to be used as netmask to convert. ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if network was converted successfully; otherwise, false. TryParse(string, bool, out IPNetwork2) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static bool TryParse(string network, bool sanitanize, out IPNetwork2 ipnetwork) Parameters network string A string containing an ip network to convert. sanitanize bool If true, removes invalid characters and normalizes whitespace from the network string, keeping only valid network address characters (0-9, a-f, A-F, ., /, :, and spaces). ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if network was converted successfully; otherwise, false. TryParse(string, byte, out IPNetwork2) 192.168.168.100/24 Network : 192.168.168.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.168.1 End : 192.168.168.254 Broadcast : 192.168.168.255. public static bool TryParse(string ipaddress, byte cidr, out IPNetwork2 ipnetwork) Parameters ipaddress string A string containing an ip address to convert. cidr byte A byte representing the netmask in cidr format (/24). ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if ipaddress/cidr was converted successfully; otherwise, false. TryParse(string, ICidrGuess, bool, out IPNetwork2) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static bool TryParse(string network, ICidrGuess cidrGuess, bool sanitanize, out IPNetwork2 ipnetwork) Parameters network string A string containing an ip network to convert. cidrGuess ICidrGuess A ICidrGuess implementation that will be used to guess CIDR during conversion. sanitanize bool If true, removes invalid characters and normalizes whitespace from the network string, keeping only valid network address characters (0-9, a-f, A-F, ., /, :, and spaces). ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if network was converted successfully; otherwise, false. TryParse(string, ICidrGuess, out IPNetwork2) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static bool TryParse(string network, ICidrGuess cidrGuess, out IPNetwork2 ipnetwork) Parameters network string A string containing an ip network to convert. cidrGuess ICidrGuess A ICidrGuess implementation that will be used to guess CIDR during conversion. ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if network was converted successfully; otherwise, false. TryParse(string, out IPNetwork2) 192.168.0.1/24 192.168.0.1 255.255.255.0 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.0.1 End : 192.168.0.254 Broadcast : 192.168.0.255. public static bool TryParse(string network, out IPNetwork2 ipnetwork) Parameters network string A string containing an ip network to convert. ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if network was converted successfully; otherwise, false. TryParse(string, string, out IPNetwork2) 192.168.168.100 - 255.255.255.0 Network : 192.168.168.0 Netmask : 255.255.255.0 Cidr : 24 Start : 192.168.168.1 End : 192.168.168.254 Broadcast : 192.168.168.255. public static bool TryParse(string ipaddress, string netmask, out IPNetwork2 ipnetwork) Parameters ipaddress string A string containing an ip address to convert. netmask string A string containing a netmask to convert (255.255.255.0). ipnetwork IPNetwork2 When this method returns, contains the IPNetwork value equivalent of the IPAddress contained in ipaddress with the netmask corresponding to cidr, if the conversion succeeded, or null if the conversion failed. The conversion fails if the s parameter is null or Empty, is not of the correct format, or represents an invalid ip address. This parameter is passed uninitialized; any value originally supplied in result will be overwritten. Returns bool true if ipaddress/netmask was converted successfully; otherwise, false. TryParseCidr(string, AddressFamily, out byte?) Try to parse cidr. Have to be >= 0 and <= 32 or 128. public static bool TryParseCidr(string sidr, AddressFamily family, out byte? cidr) Parameters sidr string A string representing a byte CIRD (/24). family AddressFamily Either IPv4 or IPv6. cidr byte? The resulting CIDR as byte. Returns bool true if cidr was converted successfully; otherwise, false. TryParseRange(string, out IEnumerable<IPNetwork2>) 192.168.1.45 - 192.168.1.65 192.168.1.45/32 (covers: 192.168.1.45) 192.168.1.46/31 (covers: 192.168.1.46 - 192.168.1.47) 192.168.1.48/28 (covers: 192.168.1.48 - 192.168.1.63) 192.168.1.64/31 (covers: 192.168.1.64 - 192.168.1.65) public static bool TryParseRange(string range, out IEnumerable<IPNetwork2> ipnetworks) Parameters range string A string containing an ip range to convert (192.168.1.45 - 192.168.1.65). ipnetworks IEnumerable<IPNetwork2> An IPNetwork List equivalent to the network contained in the range Returns bool true if parse was successful, false if the parse failed. TryParseRange(string, string, out IEnumerable<IPNetwork2>) 192.168.1.45 - 192.168.1.65 192.168.1.45/32 (covers: 192.168.1.45) 192.168.1.46/31 (covers: 192.168.1.46 - 192.168.1.47) 192.168.1.48/28 (covers: 192.168.1.48 - 192.168.1.63) 192.168.1.64/31 (covers: 192.168.1.64 - 192.168.1.65) public static bool TryParseRange(string start, string end, out IEnumerable<IPNetwork2> ipnetworks) Parameters start string A string containing an ip range start (192.168.1.45 - 192.168.1.65). end string A string containing an ip range end (192.168.1.45 - 192.168.1.65). ipnetworks IEnumerable<IPNetwork2> An IPNetwork List equivalent to the network contained in the range Returns bool true if parse was successful, false if the parse failed. TrySubnet(byte, out IPNetworkCollection) Subnet a network into multiple nets of cidr mask Subnet 192.168.0.0/24 into cidr 25 gives 192.168.0.0/25, 192.168.0.128/25 Subnet 10.0.0.0/8 into cidr 9 gives 10.0.0.0/9, 10.128.0.0/9. public bool TrySubnet(byte cidr1, out IPNetworkCollection ipnetworkCollection) Parameters cidr1 byte A byte representing the CIDR to be used to subnet the current IPNetwork. ipnetworkCollection IPNetworkCollection The resulting subnetted IPNetwork. Returns bool true if network was split successfully; otherwise, false. TrySubnet(IPNetwork2, byte, out IPNetworkCollection) Subnet a network into multiple nets of cidr mask Subnet 192.168.0.0/24 into cidr 25 gives 192.168.0.0/25, 192.168.0.128/25 Subnet 10.0.0.0/8 into cidr 9 gives 10.0.0.0/9, 10.128.0.0/9. [Obsolete(\"static TrySubnet is deprecated, please use instance TrySubnet.\")] public static bool TrySubnet(IPNetwork2 network, byte cidr, out IPNetworkCollection ipnetworkCollection) Parameters network IPNetwork2 The network. cidr byte A byte representing the CIDR to be used to subnet the current IPNetwork. ipnetworkCollection IPNetworkCollection The resulting subnetted IPNetwork. Returns bool true if network was split successfully; otherwise, false. TrySubtract(IPNetwork2, out List<IPNetwork2>) Implementation for IP network symmetric difference (subtraction) 0.0.0.0/0 - 10.0.0.1/32 = [ 0.0.0.0/5, 8.0.0.0/7, 10.0.0.0/32, 10.0.0.2/31, 10.0.0.4/30, 10.0.0.8/29, 10.0.0.16/28, 10.0.0.32/27, 10.0.0.64/26, 10.0.0.128/25, 10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, 10.0.8.0/21, 10.0.16.0/20, 10.0.32.0/19, 10.0.64.0/18, 10.0.128.0/17, 10.1.0.0/16, 10.2.0.0/15, 10.4.0.0/14, 10.8.0.0/13, 10.16.0.0/12, 10.32.0.0/11, 10.64.0.0/10, 10.128.0.0/9, 11.0.0.0/8, 12.0.0.0/6, 16.0.0.0/4, 32.0.0.0/3, 64.0.0.0/2, 128.0.0.0/1 ]. public bool TrySubtract(IPNetwork2 network2, out List<IPNetwork2> result) Parameters network2 IPNetwork2 The network to supernet with. result List<IPNetwork2> The resulting IPNetwork. Returns bool true if network2 was subtracted successfully; otherwise, false. TrySupernet(IPNetwork2, IPNetwork2, out IPNetwork2) Try to supernet two consecutive cidr equal subnet into a single one 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 10.1.0.0/16 + 10.0.0.0/16 = 10.0.0.0/15 192.168.0.0/24 + 192.168.0.0/25 = 192.168.0.0/24. [Obsolete(\"static TrySupernet is deprecated, please use instance TrySupernet.\")] public static bool TrySupernet(IPNetwork2 network, IPNetwork2 network2, out IPNetwork2 supernet) Parameters network IPNetwork2 the network. network2 IPNetwork2 The network to supernet with. supernet IPNetwork2 The resulting IPNetwork. Returns bool true if network2 was super netted successfully; otherwise, false. TrySupernet(IPNetwork2, out IPNetwork2) Try to supernet two consecutive cidr equal subnet into a single one 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 10.1.0.0/16 + 10.0.0.0/16 = 10.0.0.0/15 192.168.0.0/24 + 192.168.0.0/25 = 192.168.0.0/24. public bool TrySupernet(IPNetwork2 network2, out IPNetwork2 supernet) Parameters network2 IPNetwork2 The network to supernet with. supernet IPNetwork2 The resulting IPNetwork. Returns bool true if network2 was super netted successfully; otherwise, false. TrySupernet(IPNetwork2[], out IPNetwork2[]) Supernet a list of subnet 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 192.168.0.0/24 + 192.168.1.0/24 + 192.168.2.0/24 + 192.168.3.0/24 = 192.168.0.0/22. public static bool TrySupernet(IPNetwork2[] ipnetworks, out IPNetwork2[] supernet) Parameters ipnetworks IPNetwork2[] A list of IPNetwork to merge into common supernets. supernet IPNetwork2[] The result of IPNetwork merges. Returns bool true if ipnetworks was supernetted successfully; otherwise, false. TryToBigInteger(IPAddress, out BigInteger) Convert an IPAddress to decimal 0.0.0.0 -> 0 0.0.1.0 -> 256. public static bool TryToBigInteger(IPAddress ipaddress, out BigInteger uintIpAddress) Parameters ipaddress IPAddress A string containing an ip address to convert. uintIpAddress BigInteger A number representing the IPAddress. Returns bool true if ipaddress was converted successfully; otherwise, false. TryToCidr(IPAddress, out byte) Convert netmask to CIDR 255.255.255.0 -> 24 255.255.0.0 -> 16 255.0.0.0 -> 8. public static bool TryToCidr(IPAddress netmask, out byte cidr) Parameters netmask IPAddress An IPAddress representing the CIDR to convert. cidr byte A byte representing the netmask in cidr format (/24). Returns bool true if netmask was converted successfully; otherwise, false. TryToNetmask(byte, AddressFamily, out IPAddress) Convert CIDR to netmask 24 -> 255.255.255.0 16 -> 255.255.0.0 8 -> 255.0.0.0. public static bool TryToNetmask(byte cidr, AddressFamily family, out IPAddress netmask) Parameters cidr byte A byte representing the netmask in cidr format (/24). family AddressFamily Either IPv4 or IPv6. netmask IPAddress The resulting netmask. Returns bool true if cidr was converted successfully; otherwise, false. TryToUint(byte, AddressFamily, out BigInteger) Convert a cidr to uint netmask. public static bool TryToUint(byte cidr, AddressFamily family, out BigInteger uintNetmask) Parameters cidr byte A byte representing the netmask in cidr format (/24). family AddressFamily Either IPv4 or IPv6. uintNetmask BigInteger A number representing the netmask. Returns bool true if cidr was converted successfully; otherwise, false. TryWideSubnet(IPNetwork2[], out IPNetwork2) Attempts to find the widest subnet that contains both the start and end IP addresses. objects. public static bool TryWideSubnet(IPNetwork2[] ipnetworks, out IPNetwork2 ipnetwork) Parameters ipnetworks IPNetwork2[] An array of IPNetwork2 objects to wide subnet. ipnetwork IPNetwork2 When this method returns, contains the wide subnet of the IPNetwork2 objects, if wide subnet was successful; otherwise, null. Returns bool true if wide subnet was successful; otherwise, false. ValidNetmask(IPAddress) return true if netmask is a valid netmask 255.255.255.0, 255.0.0.0, 255.255.240.0, ... public static bool ValidNetmask(IPAddress netmask) Parameters netmask IPAddress A number representing the netmask to validate. Returns bool true if netmask is a valid IP Netmask; otherwise, false. WideSubnet(IPNetwork2[]) Finds the widest subnet from an array of IP networks. public static IPNetwork2 WideSubnet(IPNetwork2[] ipnetworks) Parameters ipnetworks IPNetwork2[] An array of IPNetwork2 objects representing the IP networks. Returns IPNetwork2 The widest subnet as an IPNetwork2 object. WideSubnet(string, string) Finds the widest subnet that can contain both the start and end IP addresses. public static IPNetwork2 WideSubnet(string start, string end) Parameters start string The starting IP address. end string The ending IP address. Returns IPNetwork2 The widest subnet that contains both the start and end IP addresses. Exceptions ArgumentNullException Thrown when either the start or end IP address is null or empty. ArgumentException Thrown when the start or end IP addresses are not valid. NotSupportedException Thrown when the start and end IP addresses have different address families. Operators operator +(IPNetwork2, int) Behavior The addition operator (+) performs the following operations: Network Expansion: Adds the specified number of IP addresses to the network range Optimal Grouping: Attempts to create the most efficient network representation Multiple Networks: When a single contiguous network cannot represent the result, returns multiple networks CIDR Optimization: Automatically calculates the appropriate subnet mask for the expanded range public static IEnumerable<IPNetwork2> operator +(IPNetwork2 left, int add) Parameters left IPNetwork2 left instance. add int number. Returns IEnumerable<IPNetwork2> Adds the specified number of IP addresses to the network range. operator +(IPNetwork2, IPNetwork2) Add two IPNetwork. public static List<IPNetwork2> operator +(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns List<IPNetwork2> Try to supernet two consecutive cidr equal subnet into a single one, otherwise return both netowkrs. operator ==(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator ==(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left equals right; otherwise, false. operator >(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator >(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left is greater than right; otherwise, false. operator >=(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator >=(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left is greater than right; otherwise, false. operator !=(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator !=(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left does not equals right; otherwise, false. operator <(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator <(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left is less than right; otherwise, false. operator <=(IPNetwork2, IPNetwork2) Compares two IPNetwork. public static bool operator <=(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns bool true if left is less than right; otherwise, false. operator -(IPNetwork2, int) Add IPNetwork. public static IEnumerable<IPNetwork2> operator -(IPNetwork2 left, int subtract) Parameters left IPNetwork2 left instance. subtract int number. Returns IEnumerable<IPNetwork2> Try to supernet two consecutive cidr equal subnet into a single one, otherwise return both netowkrs. operator -(IPNetwork2, IPNetwork2) Subtract two IPNetwork. public static List<IPNetwork2> operator -(IPNetwork2 left, IPNetwork2 right) Parameters left IPNetwork2 left instance. right IPNetwork2 Right instance. Returns List<IPNetwork2> The symmetric difference (subtraction) of two networks."
  },
  "api/System.Net.IPNetwork2UlaExtension.html": {
    "href": "api/System.Net.IPNetwork2UlaExtension.html",
    "title": "Class IPNetwork2UlaExtension | IPNetwork",
    "summary": "Class IPNetwork2UlaExtension Namespace System.Net Assembly System.Net.IPNetwork.dll Extension methods for IPNetwork2 to support ULA operations. public static class IPNetwork2UlaExtension Inheritance object IPNetwork2UlaExtension Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods IsLocallyAssignedUla(IPNetwork2) Determines if this network is a locally assigned ULA (fd00::/8). public static bool IsLocallyAssignedUla(this IPNetwork2 network) Parameters network IPNetwork2 The network to check. Returns bool True if the network is locally assigned ULA, false otherwise. IsUla(IPNetwork2) Determines if this network is a Unique Local Address (ULA). public static bool IsUla(this IPNetwork2 network) Parameters network IPNetwork2 The network to check. Returns bool True if the network is a ULA, false otherwise."
  },
  "api/System.Net.IPNetworkCollection.html": {
    "href": "api/System.Net.IPNetworkCollection.html",
    "title": "Class IPNetworkCollection | IPNetwork",
    "summary": "Class IPNetworkCollection Namespace System.Net Assembly System.Net.IPNetwork.dll Represents a collection of IP networks based on a given parent IP network and subnet CIDR. public class IPNetworkCollection : IEnumerable<IPNetwork2>, IEnumerable, IEnumerator<IPNetwork2>, IEnumerator, IDisposable Inheritance object IPNetworkCollection Implements IEnumerable<IPNetwork2> IEnumerable IEnumerator<IPNetwork2> IEnumerator IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count Gets the total number of IP addresses in the subnet. public BigInteger Count { get; } Property Value BigInteger Current Gets the element in the collection at the current position of the enumerator. public IPNetwork2 Current { get; } Property Value IPNetwork2 The element in the collection at the current position of the enumerator. this[BigInteger] Retrieves an IPNetwork2 object from the collection by index. public IPNetwork2 this[BigInteger i] { get; } Parameters i BigInteger The index of the IPNetwork2 object to retrieve. Property Value IPNetwork2 The IPNetwork2 object at the specified index. Exceptions ArgumentOutOfRangeException Thrown when the specified index is greater than or equal to the Count of the collection. Methods Dispose() Releases all resources used by the object. public void Dispose() Remarks This method implements the IDisposable interface and releases any resources held by the object. In this particular implementation, there are no resources to dispose of, so the method does nothing. Dispose(bool) Dispose instance protected virtual void Dispose(bool disposing) Parameters disposing bool MoveNext() Moves the enumerator to the next element in the collection. public bool MoveNext() Returns bool true if the enumerator was successfully moved to the next element; false if the enumerator has reached the end of the collection. Reset() Sets the enumerator to its initial position, which is before the first element in the collection. public void Reset()"
  },
  "api/System.Net.UniqueLocalAddress.html": {
    "href": "api/System.Net.UniqueLocalAddress.html",
    "title": "Class UniqueLocalAddress | IPNetwork",
    "summary": "Class UniqueLocalAddress Namespace System.Net Assembly System.Net.IPNetwork.dll Utility class for IPv6 Unique Local Address (ULA) generation and validation. Implements RFC 4193 for generating ULA prefixes in the fd00::/8 range. A locally-assigned ULA always looks like this (128 bits total): | 8 bits | 40 bits | 16 bits | 64 bits | +---------+----------------+-------------+-------------------+ | fd (8) | Global ID | Subnet ID | Interface ID | • fd = the fixed 8-bit prefix (fd00::/8 for locally assigned). • Global ID = 40 random bits, chosen once to make your ULA unique. • Subnet ID = 16 bits, chosen by you inside your site. • Interface ID = 64 bits, assigned to each host within the subnet (same rule as all IPv6). The /48 prefix is the site prefix (fdXX:XXXX:XXXX::/48). public static class UniqueLocalAddress Inheritance object UniqueLocalAddress Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields UlaCentrallyAssigned ULA prefix for centrally assigned addresses (fc00::/8) - currently undefined. public static readonly IPNetwork2 UlaCentrallyAssigned Field Value IPNetwork2 UlaLocallyAssigned ULA prefix for locally assigned addresses (fd00::/8). public static readonly IPNetwork2 UlaLocallyAssigned Field Value IPNetwork2 UlaRange Full ULA range (fc00::/7). public static readonly IPNetwork2 UlaRange Field Value IPNetwork2 Methods CreateUlaSubnet(IPNetwork2, int) Creates a ULA subnet within a ULA /48 prefix. public static IPNetwork2 CreateUlaSubnet(IPNetwork2 ulaPrefix, int subnetId) Parameters ulaPrefix IPNetwork2 The ULA /48 prefix. subnetId int 16-bit subnet identifier. Returns IPNetwork2 A ULA /64 subnet. GenerateUlaPrefix() Generates a random ULA /48 prefix using the algorithm from RFC 4193. public static IPNetwork2 GenerateUlaPrefix() Returns IPNetwork2 A randomly generated ULA /48 network. GenerateUlaPrefix(byte[]) Generates a random ULA /48 prefix using a specific MAC address for entropy. public static IPNetwork2 GenerateUlaPrefix(byte[] macAddress) Parameters macAddress byte[] MAC address to use for entropy generation. Returns IPNetwork2 A ULA /48 network generated using the provided MAC address. GenerateUlaPrefix(string) Generates a random ULA /48 prefix using a seed for deterministic generation. public static IPNetwork2 GenerateUlaPrefix(string seed) Parameters seed string Seed value for deterministic generation. Returns IPNetwork2 A ULA /48 network generated using the provided seed. IsLocallyAssignedUla(IPNetwork2) Validates whether a network is a locally assigned ULA (fd00::/8). public static bool IsLocallyAssignedUla(IPNetwork2 network) Parameters network IPNetwork2 Network to validate. Returns bool True if the network is locally assigned ULA, false otherwise. IsUla(IPAddress) Validates whether an IP address is within the ULA range. public static bool IsUla(IPAddress address) Parameters address IPAddress IP address to validate. Returns bool True if the address is a ULA, false otherwise. IsUlaPrefix(IPNetwork2) Validates whether a network is within the ULA range. public static bool IsUlaPrefix(IPNetwork2 network) Parameters network IPNetwork2 Network to validate. Returns bool True if the network is a ULA, false otherwise."
  },
  "api/System.Net.html": {
    "href": "api/System.Net.html",
    "title": "Namespace System.Net | IPNetwork",
    "summary": "Namespace System.Net Classes BigIntegerExtensions Extension methods to convert BigInteger instances to hexadecimal, octal, and binary strings. CidrClassFull Class CidrClassFull tries to guess CIDR in a ClassFull way. CidrClassLess Try to guess a CIDR in a ClassLess way: ipv4 = 32, ipv6 = 128. CidrGuess A static helper CidrGuess class. CidrNetworkAware If your CidrGuess is “network-aware” based only on what humans usually encode in the textual address, a good heuristic is: IPv4 (dotted-quad) • Treat trailing 0s as “network bits” and trailing 255s as a “wildcard” hint for the same boundary. • Otherwise, fall back to /32 (no safe aggregation from the string alone). • Special case: 0.0.0.0 (or 255.255.255.255) → /0. Rule of thumb Ends with .0 → /24 Ends with .0.0 or .255.255 → /16 Ends with .0.0.0 or .255.255.255 → /8 Else → /32 Matches your examples Parse(\"192.0.43.8\") → /32 Parse(\"192.0.43.0\") → /24 Parse(\"192.43.0.0\") → /16 Parse(\"192.0.43.255\") → /24 (wildcard hint) Parse(\"192.43.255.255\") → /16 (wildcard hint) So: in a network-aware context like this, you generally don’t emit /25, /26, etc., because there’s no reliable visual cue for those in dotted-quad—stick to /32, /24, /16, /8, /0. IPv6 (colon-hex) IPv6 is grouped by hextets (16-bit chunks), so mirror the idea at 16-bit boundaries. Use trailing :0000 hextets as “network bits”. Otherwise, fall back to /128. Note: operationally, /64 is the standard host subnet size, but you should still infer from the string, not assumptions. Rule of thumb Ends with :0000 → /112 Ends with :0000:0000 → /96 Ends with three trailing :0000 → /80 … Ends with four trailing :0000 → /64 Else → /128 Examples 2001:db8:1:2:3:4:5:6 → /128 2001:db8:1:2:3:4:5:0000 → /112 2001:db8:1:2:3:4:0000:0000 → /96 2001:db8:1:2:3:0000:0000:0000 → /80 2001:db8:1:2:0000:0000:0000:0000 → /64 TL;DR IPv4: stick to /32, /24, /16, /8, /0 based on trailing .0/.255; otherwise /32. IPv6: infer /128, /112, /96, /80, /64, … based on trailing :0000 groups; otherwise /128. IPAddressCollection Represents a collection of IP addresses within a specific IP network. IPAddressExtensions A collection of extension functions applied to an IPAddress value. IPNetwork2 IP Network utility class. Use IPNetwork.Parse to create instances. IPNetwork2UlaExtension Extension methods for IPNetwork2 to support ULA operations. IPNetworkCollection Represents a collection of IP networks based on a given parent IP network and subnet CIDR. UniqueLocalAddress Utility class for IPv6 Unique Local Address (ULA) generation and validation. Implements RFC 4193 for generating ULA prefixes in the fd00::/8 range. A locally-assigned ULA always looks like this (128 bits total): | 8 bits | 40 bits | 16 bits | 64 bits | +---------+----------------+-------------+-------------------+ | fd (8) | Global ID | Subnet ID | Interface ID | • fd = the fixed 8-bit prefix (fd00::/8 for locally assigned). • Global ID = 40 random bits, chosen once to make your ULA unique. • Subnet ID = 16 bits, chosen by you inside your site. • Interface ID = 64 bits, assigned to each host within the subnet (same rule as all IPv6). The /48 prefix is the site prefix (fdXX:XXXX:XXXX::/48). Interfaces ICidrGuess An interface to have multiple implemntatino ao CIDR Guesser. Enums Filter Represents different filters for a collection of items. FilterEnum Represents different filters for a collection of items."
  },
  "index.html": {
    "href": "index.html",
    "title": "IPNetwork utility classes for .Net | IPNetwork",
    "summary": "IPNetwork utility classes for .Net IPNetwork utility classes take care of complex network, IP, IPv4, IPv6, netmask, CIDR, subnet, subnetting, supernet, and supernetting calculation for .NET developers. It works with IPv4 as well as IPv6, is written in C#, has a light and clean API, and is fully unit-tested with 100% code coverage. Installation nuget install IPNetwork2 IPNetwork library Example 1 (IPv6) IPNetwork2 ipnetwork = IPNetwork2.Parse(\"2001:0db8::/64\"); Console.WriteLine(\"Network : {0}\", ipnetwork.Network); Console.WriteLine(\"Netmask : {0}\", ipnetwork.Netmask); Console.WriteLine(\"Broadcast : {0}\", ipnetwork.Broadcast); Console.WriteLine(\"FirstUsable : {0}\", ipnetwork.FirstUsable); Console.WriteLine(\"LastUsable : {0}\", ipnetwork.LastUsable); Console.WriteLine(\"Usable : {0}\", ipnetwork.Usable); Console.WriteLine(\"Cidr : {0}\", ipnetwork.Cidr); Output Network : 2001:db8:: Netmask : ffff:ffff:ffff:ffff:: Broadcast : FirstUsable : 2001:db8:: LastUsable : 2001:db8::ffff:ffff:ffff:ffff Usable : 18446744073709551616 Cidr : 64 Example 2 (IPv6) IPNetwork2 ipnetwork = IPNetwork2.Parse(\"2001:0db8::/64\"); IPAddress ipaddress = IPAddress.Parse(\"2001:0db8::1\"); IPAddress ipaddress2 = IPAddress.Parse(\"2001:0db9::1\"); IPNetwork2 ipnetwork2 = IPNetwork2.Parse(\"2001:0db8::1/128\"); IPNetwork2 ipnetwork3 = IPNetwork2.Parse(\"2001:0db9::1/64\"); bool contains1 = ipnetwork.Contains(ipaddress); bool contains2 = ipnetwork.Contains(ipaddress2); bool contains3 = ipnetwork.Contains(ipnetwork2); bool contains4 = ipnetwork.Contains(ipnetwork3); bool overlap1 = ipnetwork.Overlap(ipnetwork2); bool overlap2 = ipnetwork.Overlap(ipnetwork3); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipaddress, contains1); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipaddress2, contains2); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipnetwork2, contains3); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipnetwork3, contains4); Console.WriteLine(\"{0} overlap {1} : {2}\", ipnetwork, ipnetwork2, overlap1); Console.WriteLine(\"{0} overlap {1} : {2}\", ipnetwork, ipnetwork3, overlap2); Output 2001:db8::/64 contains 2001:db8::1 : True 2001:db8::/64 contains 2001:db9::1 : False 2001:db8::/64 contains 2001:db8::1/128 : True 2001:db8::/64 contains 2001:db9::/64 : False 2001:db8::/64 overlap 2001:db8::1/128 : True 2001:db8::/64 overlap 2001:db9::/64 : False Example 3 (IPv6) IPNetwork2 wholeInternet = IPNetwork2.Parse(\"::/0\"); byte newCidr = 2; IPNetworkCollection subneted = wholeInternet.Subnet(newCidr); Console.WriteLine(\"{0} was subnetted into {1} subnets\", wholeInternet, subneted.Count); Console.WriteLine(\"First: {0}\", subneted[0]); Console.WriteLine(\"Last : {0}\", subneted[subneted.Count - 1]); Console.WriteLine(\"All :\"); foreach (IPNetwork2 ipnetwork in subneted) { Console.WriteLine(\"{0}\", ipnetwork); } Output ::/0 was subnetted into 4 subnets First: ::/2 Last : c000::/2 All : ::/2 4000::/2 8000::/2 c000::/2 Example 4 (IPv6) IPNetwork2 ipnetwork1 = IPNetwork2.Parse(\"2001:0db8::/32\"); IPNetwork2 ipnetwork2 = IPNetwork2.Parse(\"2001:0db9::/32\"); IPNetwork2[] ipnetwork3 = IPNetwork2.Supernet(new[] { ipnetwork1, ipnetwork2 }); Console.WriteLine(\"{0} + {1} = {2}\", ipnetwork1, ipnetwork2, ipnetwork3[0]); Output 2001:db8::/32 + 2001:db9::/32 = 2001:db8::/31 Example 5 IPNetwork2 ipnetwork = IPNetwork2.Parse(\"192.168.168.100/24\"); Console.WriteLine(\"Network : {0}\", ipnetwork.Network); Console.WriteLine(\"Netmask : {0}\", ipnetwork.Netmask); Console.WriteLine(\"Broadcast : {0}\", ipnetwork.Broadcast); Console.WriteLine(\"FirstUsable : {0}\", ipnetwork.FirstUsable); Console.WriteLine(\"LastUsable : {0}\", ipnetwork.LastUsable); Console.WriteLine(\"Usable : {0}\", ipnetwork.Usable); Console.WriteLine(\"Cidr : {0}\", ipnetwork.Cidr); Output Network : 192.168.168.0 Netmask : 255.255.255.0 Broadcast : 192.168.168.255 FirstUsable : 192.168.168.1 LastUsable : 192.168.168.254 Usable : 254 Cidr : 24 Example 6 IPNetwork2 ipnetwork = IPNetwork2.Parse(\"192.168.0.0/24\"); IPAddress ipaddress = IPAddress.Parse(\"192.168.0.100\"); IPAddress ipaddress2 = IPAddress.Parse(\"192.168.1.100\"); IPNetwork2 ipnetwork2 = IPNetwork2.Parse(\"192.168.0.128/25\"); IPNetwork2 ipnetwork3 = IPNetwork2.Parse(\"192.168.1.1/24\"); bool contains1 = ipnetwork.Contains(ipaddress); bool contains2 = ipnetwork.Contains(ipaddress2); bool contains3 = ipnetwork.Contains(ipnetwork2); bool contains4 = ipnetwork.Contains(ipnetwork3); bool overlap1 = ipnetwork.Overlap(ipnetwork2); bool overlap2 = ipnetwork.Overlap(ipnetwork3); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipaddress, contains1); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipaddress2, contains2); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipnetwork2, contains3); Console.WriteLine(\"{0} contains {1} : {2}\", ipnetwork, ipnetwork3, contains4); Console.WriteLine(\"{0} overlap {1} : {2}\", ipnetwork, ipnetwork2, overlap1); Console.WriteLine(\"{0} overlap {1} : {2}\", ipnetwork, ipnetwork3, overlap2); A Output 192.168.0.0/24 contains 192.168.0.100 : True 192.168.0.0/24 contains 192.168.1.100 : False 192.168.0.0/24 contains 192.168.0.128/25 : True 192.168.0.0/24 contains 192.168.1.0/24 : False 192.168.0.0/24 overlap 192.168.0.128/25 : True 192.168.0.0/24 overlap 192.168.1.0/24 : False Example 7 IPNetwork2 iana_a_block = IPNetwork2.IANA_ABLK_RESERVED1; IPNetwork2 iana_b_block = IPNetwork2.IANA_BBLK_RESERVED1; IPNetwork2 iana_c_block = IPNetwork2.IANA_CBLK_RESERVED1; Console.WriteLine(\"IANA_ABLK_RESERVED1 is {0}\", iana_a_block); Console.WriteLine(\"IANA_BBLK_RESERVED1 is {0}\", iana_b_block); Console.WriteLine(\"IANA_CBLK_RESERVED1 is {0}\", iana_c_block); Output IANA_ABLK_RESERVED1 is 10.0.0.0/8 IANA_BBLK_RESERVED1 is 172.16.0.0/12 IANA_CBLK_RESERVED1 is 192.168.0.0/16 Example 8 IPNetwork2 wholeInternet = IPNetwork2.Parse(\"0.0.0.0/0\"); byte newCidr = 2; IPNetworkCollection subneted = wholeInternet.Subnet(newCidr); Console.WriteLine(\"{0} was subnetted into {1} subnets\", wholeInternet, subneted.Count); Console.WriteLine(\"First: {0}\", subneted[0]); Console.WriteLine(\"Last : {0}\", subneted[subneted.Count - 1]); Console.WriteLine(\"All :\"); foreach (IPNetwork2 ipnetwork in subneted) { Console.WriteLine(\"{0}\", ipnetwork); } Output 0.0.0.0/0 was subnetted into 4 subnets First: 0.0.0.0/2 Last : 192.0.0.0/2 All : 0.0.0.0/2 64.0.0.0/2 128.0.0.0/2 192.0.0.0/2 Example 9 IPNetwork2 ipnetwork1 = IPNetwork2.Parse(\"192.168.0.0/24\"); IPNetwork2 ipnetwork2 = IPNetwork2.Parse(\"192.168.1.0/24\"); IPNetwork2[] ipnetwork3 = IPNetwork2.Supernet(new[]{ipnetwork1, ipnetwork2}); Console.WriteLine(\"{0} + {1} = {2}\", ipnetwork1, ipnetwork2, ipnetwork3[0]); Output 192.168.0.0/24 + 192.168.1.0/24 = 192.168.0.0/23 Example 10 - ClassLess network parse If you don't specify the network cidr, IPNetwork will try to guess the CIDR for you. There are two strategies to guess ClassFull (default) and ClassLess. ClassFull (default strategy) is based on the default Class A, B or C networks. IPV4 : Class A: 0 - 127 with a mask of 255.0.0.0 (/8) Class B: 128 - 191 with a mask of 255.255.0.0 (/16) Class C: 192 - 223 with a mask of 255.255.255.0 (/24) IPV6 : /64 ClassLess IPV4 : /32 IPV6 : /128 IPv4 IPNetwork2 defaultParse= IPNetwork2.Parse(\"192.168.0.0\"); // default to ClassFull IPNetwork2 classFullParse = IPNetwork2.Parse(\"192.168.0.0\", CidrGuess.ClassFull); IPNetwork2 classLessParse = IPNetwork2.Parse(\"192.168.0.0\", CidrGuess.ClassLess); Console.WriteLine(\"IPV4 Default Parse : {0}\", defaultStrategy); Console.WriteLine(\"IPV4 ClassFull Parse : {0}\", classFullParse); Console.WriteLine(\"IPV4 ClassLess Parse : {0}\", classLessParse); Output IPV4 Default Parse : 192.168.0.0/24 IPV4 ClassFull Parse : 192.168.0.0/24 IPV4 ClassLess Parse : 192.168.0.0/32 IPv6 IPNetwork2 defaultParse = IPNetwork2.Parse(\"::1\"); // default to ClassFull IPNetwork2 classFullParse = IPNetwork2.Parse(\"::1\", CidrGuess.ClassFull); IPNetwork2 classLessParse = IPNetwork2.Parse(\"::1\", CidrGuess.ClassLess); Console.WriteLine(\"IPV6 Default Parse : {0}\", defaultParse); Console.WriteLine(\"IPV6 ClassFull Parse : {0}\", classFullParse); Console.WriteLine(\"IPV6 ClassLess Parse : {0}\", classLessParse); Output IPV6 Default Parse : ::/64 IPV6 ClassFull Parse : ::/64 IPV6 ClassLess Parse : ::1/128 IPNetwork utility command line IPNetwork utility command line take care of complex network, ip, netmask, subnet, cidr calculation for command line. It works with IPv4, it is written in C# and has a light and clean API and is fully unit tested. Below some examples : Provide at least one ipnetwork Usage: ipnetwork [-inmcbflu] [-d cidr|-D] [-h|-s cidr|-S|-w|-W|-x|-C network|-o network] networks ... Version: 3.1.0 Print options -i : network -n : network address -m : netmask -c : cidr -b : broadcast -f : first usable ip address -l : last usable ip address -u : number of usable ip addresses -t : total number of ip addresses Parse options -d cidr : use cidr if not provided (default /32) -D : IPv4 only - use default cidr (ClassA/8, ClassB/16, ClassC/24) Actions -h : help message -s cidr : split network into cidr subnets -w : supernet networks into smallest possible subnets -W : supernet networks into one single subnet -x : list all ipadresses in networks -C network : network contain networks -o network : network overlap networks -S network : substract network from subnet networks : one or more network addresses (1.2.3.4 10.0.0.0/8 10.0.0.0/255.0.0.0 2001:db8::/32 2001:db8:1:2:3:4:5:6/128 ) Example 10 Display ipnetwork informations : c:\\> ipnetwork 10.0.0.0/8 IPNetwork : 10.0.0.0/8 Network : 10.0.0.0 Netmask : 255.0.0.0 Cidr : 8 Broadcast : 10.255.255.255 FirstUsable : 10.0.0.1 LastUsable : 10.255.255.254 Usable : 16777214 Example 11 Split network into cidr c:\\> ipnetwork -s 9 10.0.0.0/8 IPNetwork : 10.0.0.0/9 Network : 10.0.0.0 Netmask : 255.128.0.0 Cidr : 9 Broadcast : 10.127.255.255 FirstUsable : 10.0.0.1 LastUsable : 10.127.255.254 Usable : 8388606 -- IPNetwork : 10.128.0.0/9 Network : 10.128.0.0 Netmask : 255.128.0.0 Cidr : 9 Broadcast : 10.255.255.255 FirstUsable : 10.128.0.1 LastUsable : 10.255.255.254 Usable : 8388606 Example 12 supernet networks into smallest possible subnets C:\\>ipnetwork -w 192.168.0.0/24 192.168.1.0/24 IPNetwork : 192.168.0.0/23 Network : 192.168.0.0 Netmask : 255.255.254.0 Cidr : 23 Broadcast : 192.168.1.255 FirstUsable : 192.168.0.1 LastUsable : 192.168.1.254 Usable : 510 Example 13 supernet networks into smallest possible subnets c:\\> ipnetwork -w 192.168.0.0/24 192.168.2.0/24 IPNetwork : 192.168.0.0/24 Network : 192.168.0.0 Netmask : 255.255.255.0 Cidr : 24 Broadcast : 192.168.0.255 FirstUsable : 192.168.0.1 LastUsable : 192.168.0.254 Usable : 254 -- IPNetwork : 192.168.2.0/24 Network : 192.168.2.0 Netmask : 255.255.255.0 Cidr : 24 Broadcast : 192.168.2.255 FirstUsable : 192.168.2.1 LastUsable : 192.168.2.254 Usable : 254 Example 14 supernet networks into smallest possible subnets C:\\>ipnetwork -W 192.168.0.0/24 192.168.129.0/24 IPNetwork : 192.168.0.0/16 Network : 192.168.0.0 Netmask : 255.255.0.0 Cidr : 16 Broadcast : 192.168.255.255 FirstUsable : 192.168.0.1 LastUsable : 192.168.255.254 Usable : 65534 Example 15 Split network into cidr, display full network only C:\\>ipnetwork -i -s 12 10.0.0.0/8 | grep -v \\-\\- IPNetwork : 10.0.0.0/12 IPNetwork : 10.16.0.0/12 IPNetwork : 10.32.0.0/12 IPNetwork : 10.48.0.0/12 IPNetwork : 10.64.0.0/12 IPNetwork : 10.80.0.0/12 IPNetwork : 10.96.0.0/12 IPNetwork : 10.112.0.0/12 IPNetwork : 10.128.0.0/12 IPNetwork : 10.144.0.0/12 IPNetwork : 10.160.0.0/12 IPNetwork : 10.176.0.0/12 IPNetwork : 10.192.0.0/12 IPNetwork : 10.208.0.0/12 IPNetwork : 10.224.0.0/12 IPNetwork : 10.240.0.0/12 Example 16 Test if an ip is contained in a network C:\\>ipnetwork -C 10.0.0.1 10.0.0.0/8 10.0.1.0/24 10.0.0.1/32 contains 10.0.0.0/8 : False 10.0.0.1/32 contains 10.0.1.0/24 : False Example 17 Test if a network overlap another network C:\\>ipnetwork -o 10.0.0.1/24 10.0.0.0/8 10.0.1.0/24 10.0.0.0/24 overlaps 10.0.0.0/8 : True 10.0.0.0/24 overlaps 10.0.1.0/24 : False Example 18 remove one ip from a class and regroup them into the smallest possible network C:\\> ipnetwork -i -s 32 192.168.0.0/24 \\ | grep -v \\-\\- \\ | awk \"{print $3;}\" \\ | grep -v 192.168.0.213/32 \\ | xargs ipnetwork -i -w \\ | grep -v \\-\\- IPNetwork : 192.168.0.224/27 IPNetwork : 192.168.0.216/29 IPNetwork : 192.168.0.214/31 IPNetwork : 192.168.0.212/32 IPNetwork : 192.168.0.208/30 IPNetwork : 192.168.0.192/28 IPNetwork : 192.168.0.128/26 IPNetwork : 192.168.0.0/25 Example 18 (IPv6) IPv6 networks ipnetwork.exe 2001:0db8::/128 IPNetwork : 2001:db8::/128 Network : 2001:db8:: Netmask : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff Cidr : 128 Broadcast : 2001:db8:: FirstUsable : 2001:db8:: LastUsable : 2001:db8:: Usable : 0 Total : 1 Have fun ! License"
  }
}